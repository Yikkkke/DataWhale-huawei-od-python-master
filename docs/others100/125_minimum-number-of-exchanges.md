# 125 最少交换次数

## 题目描述

给出数字`K`，请输出所有结果小于`K`的整数组合到一起的最少交换次数。组合一起是指满足条件的数字相邻，不要求相邻后在数组中的位置。

数据范围：
- -100 <= K <= 100
- -100 <= 数组中元素 <= 100

## 输入描述

第1行表示输入数组，第2行输入`K`数值。

## 输出描述

输出最少交换次数。

## 示例描述

### 示例一

**输入：**
```text
1 3 1 4 0
2
```

**输出：**
```text
1
```

**说明：**  
小于2的表达式是1 1 0，共三种可能，将所有符合要求的数字组合在一起，最少交换1次。

### 示例二

**输入：**
```text
0 0 0 1 0
2
```

**输出：**
```text
0
```

### 示例三

**输入：**
```text
2 3 2
1
```

**输出：**
```text
0
```

## 解题思路

1. 得到小于`K`的掩码数组`less_k_arr`。
2. 将掩码数组求和，得到需要相邻的数字个数`m`。
3. 对掩码数组使用滑动窗口求和，得到每个窗口内已满足条件的个数的数组`dp`。
4. 使用`m`减去`dp`数组中的最大值，即得到最少交换次数。可理解为，为了使元素相邻，还需移动几次，才能满足相邻元素的个数。

## 解题代码

```python
def solve_method(arr, k):
    # 得到小于k的掩码数组
    less_k_arr = [1 if n < k else 0 for n in arr]
    n = len(less_k_arr)
    # 得到需要相邻的数字个数
    m = sum(less_k_arr)
    
    # 使用滑动窗口求和，得到窗口内已满足条件的个数
    dp = [sum(less_k_arr[i: i + m]) for i in range(n)]
    # 得到最少交换次数
    result = m - max(dp)
    return result


if __name__ == '__main__':
    assert solve_method([1, 3, 1, 4, 0], 2) == 1
    assert solve_method([0, 0, 0, 1, 0], 2) == 0
    assert solve_method([2, 3, 2], 1) == 0
```