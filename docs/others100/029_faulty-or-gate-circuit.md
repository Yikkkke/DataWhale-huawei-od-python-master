# 029 出错的或电路

## 题目描述

某生产门电路的厂商发现某一批次的或门电路不稳定，具体现象为计算两个二进制数的或操作时，第一个二进制数中某两个比特位会出现交换，交换的比特位置是随机的，但只交换这两个位，其他位不变。很明显，这个交换可能会影响最终的或结果，也可能不会有影响。

为了评估影响和定位出错的根因，工程师需要研究在各种交换的可能下，最终的或结果发生改变的情况有多少种。

## 输入描述

第一行有一个正整数`N`，其中1 <= N <= 1000000。

第二行有一个长为`N`的二进制数，表示或电路的第一个输入数，即会发生比特交换的输入数。

第三行有一个长为`N`的二进制数，表示或电路的第二个输入数。注意第二个输入数不会发生比特交换。

## 输出描述

输出只有一个整数，表示会影响或结果的交换方案个数。

## 示例描述

### 示例一

**输入：**

```text
3
010
110
```

**输出：**

```text
1
```

**说明：**

原本`010`和`110`的或结果是`110`，但第一个输入数可能会发生如下三种交换：

- 交换第1个比特和第2个比特，第一个输入数变为`100`，计算结果为`110`，计算结果不变。
- 交换第1个比特和第3个比特，第一个输入数变为`010`，计算结果为`110`，计算结果不变。  
- 交换第2个比特和第3个比特，第一个输入数变为`001`，计算结果为`111`，计算结果改变。

故只有1种交换会改变计算结果。

### 示例二

**输入：**

```text
6
011011
110110
```

**输出：**

```text
4
```

**说明：**

原本`011011`和`110110`的或结果是`111111`，但第一个输入数发生如下比特交换会影响最终计算结果：

- 交换第1个比特和第3个比特，第一个输入数变为`110011`，计算结果变为`110111`。
- 交换第1个比特和第6个比特，第一个输入数变为`111010`，计算结果变为`111110`。
- 交换第3个比特和第4个比特，第一个输入数变为`010111`，计算结果变为`110111`。
- 交换第4个比特和第6个比特，第一个输入数变为`011110`，计算结果变为`111110`。

其他的交换都不会影响计算结果，故输出4。

## 解题思路

1. 先统计第1个二进制数的0与1的次数。
2. 遍历第2个二进制数的每一位：
    - 当第2个二进制数的某一位为1时，无论第1个二进制数对应的位改变了为什么，都不会影响结果。
    - 遇到0时，分类计数：
        - 当第1个二进制数的该位为1时，1|0=1变为0|0=0，那么统计第1个二进制数的所有0的次数，就是让电路改变结果的次数。
        - 当第1个二进制数的该位为0时，0|0=0变为1|0=1，同上，统计第1个二进制数的所有1的次数。
3. 返回统计结果。    

## 解题代码

```Python
def solve_method(binary1, binary2):
    # 先统计第1个二进制数的0与1的次数，方便后续计算次数改变
    cnt_binary1_1 = binary1.count('1')
    cnt_binary1_0 = binary1.count('0')

    # 存储结果
    count = 0

    # 遍历第2个二进制数的每一位
    for i in range(len(binary1)):
        # 遇到0时，分类计数
        if binary2[i] == '0':
            # 当第2个二进制数的某一位为1时，无论第1个二进制数对应的位改变了为什么，都不会影响结果。
            # 当某一位为0时，这时就会影响结果：
            # 当第1个二进制数的该位为1时，1|0=1变为0|0=0，那么统计第1个二进制数的所有0的次数，就是让电路改变结果的次数。
            # 当第1个二进制数的该位为0时，0|0=0变为1|0=1，同上，统计第1个二进制数的所有1的次数。
            if binary1[i] == '1':
                count += cnt_binary1_0
            if binary1[i] == '0':
                count += cnt_binary1_1
    return count


if __name__ == '__main__':
    assert solve_method("010", "110") == 1
    assert solve_method("011011", "110110") == 4
    assert solve_method("110", "001") == 2
```



