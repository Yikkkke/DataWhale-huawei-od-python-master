# 030 分积木

## 题目描述

`solo`和 `koko`是两兄弟，妈妈给了他们一大堆积木，每块积木上都有自己的重量。现在他们想要将这些积木分为两堆，哥哥`solo`负责分配，弟弟`koko`要求两个人获得的积木总重量相等（根据`koko`的逻辑），个数可以不同，不然就会哭。但`koko`只会先将两个数转成二进制再进行加法，而且总会忘记进位（每个进位都会忘记）。

例如，当`25(11101)+1(1011)`时，`koko`得到的计算结果是`18(10):11001+01011=10010`。

要让`koko`不哭，请得到`solo`想要尽可能让自己得到的积木最大的总重量。

## 输入描述

第一行是一个整数`N`，表示有多少块积木，取值范围是2 <= N <= 100。

第二行是空格分隔的`N`个整数， 其中`ci`表示第`i`块积木的重量，取值范围是1 <= ci <= 10^6。

## 输出描述

让`koko`不哭，输出`solo`所能获得积木的最大总重量，否则输出`No`。

## 示例描述

### 示例一

**输入：**

```text
3
3 5 6
```

**输出：**

```text
11
```

**说明：**

该样例输出为11，解释如下：

`solo`能获得重量为5和6的两块积木，5转成二进制为`101`，6转成二进制为`110`。

按照`koko`的计算方法（忘记进位）结果为`11`（二进制），`koko`获得重量为`3`的积木转成二进制为`11`。

`solo`和`koko`得到的积木的重量都是`11`（二进制），因此`solo`可以获得的积木的总重量是`5+6=11`（十进制）。

## 解题思路

**基本思路：** 二进制的异或运算等同于不进位的加法运算

1. 遍历每一个积木的重量：
    - 进行重复的异或运算。
2. 判断运算结果是否为0：
    - 如果为0，表示可以分为两堆，减去其中最小的值，返回最大的积木重量。
    - 如果不为0，表示无法分为两堆，返回`No`。

## 解题代码

```Python
def solve_method(blocks):
    count = 0
    for i in blocks:
        # 进行异或运算，等同于不进位的加法
        count = count ^ i
    if count == 0:
        return sum(blocks) - min(blocks)
    else:
        return "No"


if __name__ == '__main__':
    assert solve_method([3, 5, 6]) == 11
```

