# 187 获取最多食物、获取食物游戏

## 题目描述

主办方设计了一个获取食物的游戏。

游戏的地图由`N`个方格组成，每个方格上至多2个传送门，通过传送门可将参与者传送至指定的其它方格。同时，每个方格上标注了三个数字：
1. 第一个数字`id`：代表方格的编号，从0到`N-1`，每个方格各不相同。
2. 第二个数字`parent_id`：代表从编号为`parent_id`的方格可以通过传送门传送到当前方格（-1则表示没有任何方格可以通过传送门传送到此方格，这样的方格在地图中有且仅有一个）。
3. 第三个数字`value`：取值在`[100，100]`的整数值，正整数代表参与者得到相应取值单位的食物，负整数代表失去相应数值单位的食物（参与者可能存在临时持有食物为负数的情况），0则代表无变化。

此外，在地图设计时，保证了参与者不可能到达相同的方格两次，并且至少有一个方格的`value`是正整数。

游戏开始后，参与者任意选择一个方格作为出发点，当遇到下列情况之一退出游戏：

- 参与者当前所处的方格无传送门。
- 参与者在任意方格上主动宣布退出游戏。

请计算参与者退出游戏后，最多可以获得多少单位的食物。

## 输入描述

第一行输入一个数字`N`，表示方格的个数。

第2行至第`N+1`行，第一个数字是`id`，第二个数字是`parent_id`，第三个数字是`value`。

## 输出描述

获取食物的数量。

## 示例描述

### 示例一

**输入：**

```text
7
0 1 8
1 -1 -2
2 1 9
4 0 -2
5 4 3
3 0 -3
6 2 -3
```

**输出：**

```text
9
```

**说明：**

有两种方式：
- 参与者从方格0出发，通过传送门到达方格4，再通过传送门到达方格5。一共获得8+(-2)+3=9个单位食物，得到食物最多
- 参与者在游戏开始时处于方格2，直接主动宣布退出游戏，也可以获得9个单位食物。

### 示例二

**输入：**

```text
3
0 -1 3
1 0 1
2 0 2
```

**输出：**

```text
5
```

**说明：**

参与者从方格0出发，通过传送门到达方格2，一共可以获得3+2=5个单位食物，此时得到食物最多。

## 解题思路

**基本思路：** 使用深度优先搜索DFS求解。

1. 构建方格`id`字典，`key`为方格`id`，`value`为能传送的方格`id`和食物。
2. 遍历所有方格，使用深度优先搜索计算获得最多的食物：
    - 确定参数：方格`n_id`。
    - 终止条件：返回到达方格`n_id`能最多获得的食物。
    - 递归处理：
        - 如果该点的传送点为-1，则设置该点最多获得的食物为字典中对应的食物。
        - 否则，计算该点获得的食物与加上传送点获得食物的最大值。
3. 遍历比较，获取最多的食物。
4. 返回最多可以获得的食物。

## 解题代码

```python
import math


def solve_method(grids):
    def dfs(n_id):
        nonlocal dp
        if n_id not in dp:
            if nodes[n_id][0] == -1:
                dp[n_id] = nodes[n_id][1]
            else:
                dp[n_id] = max(nodes[n_id][1], nodes[n_id][1] + dfs(nodes[n_id][0]))
        return dp[n_id]

    n = len(grids)
    # 方格id字典，key为方格id，value为能传送的方格id和食物
    nodes = {}
    for i in range(n):
        node_id, pid, val = grids[i]
        if node_id < 0 or node_id >= n or pid < -1 or pid >= n:
            continue
        nodes[node_id] = [pid, val]

    max_val = -math.inf
    # dp[i]表示到达该点能获得的最大食物
    dp = {}
    for i in reversed(range(n)):
        if i not in nodes:
            continue
        max_val = max(max_val, dfs(i))

    return max_val


if __name__ == '__main__':
    arr = [[0, 1, 8],
           [1, -1, -2],
           [2, 1, 9],
           [4, 0, -2],
           [5, 4, 3],
           [3, 0, -3],
           [6, 2, -3]]
    assert solve_method(arr) == 9

    arr = [[0, -1, 3],
           [1, 0, 1],
           [2, 0, 2]]
    assert solve_method(arr) == 5
```

