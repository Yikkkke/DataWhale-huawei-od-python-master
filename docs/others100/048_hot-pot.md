# 048 吃火锅

## 题目描述

入职后，导师会请你吃饭，你选择了火锅，火锅里会在不同时间下很多菜，不同食材要煮不同时间，才能变得刚好合适。你希望吃到最多的刚好合适的菜，但是你的手速不够快，其中用`m`表示手速，每次下手捞菜后至少要过`m`秒，才能再捞（每次只能捞一个）。那么用最合理的策略，最多能吃到多少刚好合适的菜。

## 输入描述

第一行两个整数`n`、`m`，其中`n`表示往锅里下菜的个数，`m`表示手速。

接下来有`n`行，每行有两个数`x`、`y`，表示第`x`秒下的菜过`y`秒才能变得刚好合适。

取值范围：1 < m,n < 1000，1 < x,y < 1000。

## 输出描述

输出一个整数代表用最合理的策略，最多能吃到刚好合适的菜的数量。

## 示例描述

### 示例一

**输入：**
```text
2 1
1 2
2 1
```

**输出：**
```text
1
```
**说明**

一共下了两个菜，手速是1秒。
- 在第1秒下的菜，需要到第3秒吃。
- 在第2秒下的菜，也要到第3秒吃。 

所以只能吃一个。

### 示例二

**输入：**

```text
3 1
1 2
1 3
2 3
```

**输出：**
```text
3
```
**说明**

一共下了三个菜，手速是1秒。
- 第一个在第1秒下的菜，需要到第3秒吃。
- 第二个在第1秒下的菜，需要到第4秒吃。
- 第三个在第2秒下的菜，需要到第5秒吃，

所以3个菜都能吃到。


## 解题思路

1. 遍历每个菜，得到每个菜可以吃的时刻`dish_cooked_time`，并按照时刻的顺序排序（从小到大）。
2. 记录上一个吃到菜的时刻`pre_time`。
3. 遍历每个菜，如果等待的时间能吃到这次的菜，则记录吃到菜的时刻，次数`count`加1。
4. 返回次数，即可以吃到的菜的数量。

## 解题代码

```python
def solve_method(dishes, m):
    dish_cooked_time = []
    for dish in dishes:
        dish_cooked_time.append(dish[0] + dish[1])
    # 得到每个菜可以吃的时刻
    dish_cooked_time.sort()

    # 上一个吃到菜的时刻
    pre_time = dish_cooked_time[0]
    count = 1
    for i in range(1, len(dishes)):
        # 如果等待的时间能吃到这次的菜
        if dish_cooked_time[i] >= pre_time + m:
            # 记录吃到菜的时刻
            pre_time = dish_cooked_time[i]
            # 累计次数
            count += 1

    return count


if __name__ == '__main__':
    dishes = [[1, 2],
              [2, 1]]
    assert solve_method(dishes, 1) == 1

    dishes = [[1, 2],
              [1, 3],
              [2, 3]]
    assert solve_method(dishes, 1) == 3
```

