# 097 数字游戏

## 题目描述

小明玩一个游戏，系统发`1+n`张牌，每张牌上有一个整数。第一张给小明，后`n`张按照发牌顺序排成连续的一行。需要小明判断，后`n`张牌中，是否存在连续的若干张牌，其和可以整除小明手中牌上的数字。

## 输入描述

输入数据有多组，每组输入数据有两行，输入到文件结尾结束。

第一行有两个整数`n`和`m`用空格分隔。`m`代表发给小明牌上的数字。

第二行有`n`个数，代表后续发的`n`张牌上的数字，以空格分隔。

## 输出描述

对每组输入，如果存在满足条件的连续若干张牌，则输出1，否则，输出0。

**补充说明：**

- 1 <= n <= 1000
- 1 <= 牌上的整数 <= 400000
- 输入的组数，不多于1000

用例确保输入都正确，不需要考虑非法情况。

## 示例描述

### 示例一

**输入：**
```text
6 7
2 12 6 3 5 5
10 11
1 1 1 1 1 1 1 1 1 1
```

**输出：**
```text
1
0
```

**说明：**  

两组输入。第一组小明牌的数字为7，再发了6张牌。

第1、2两张牌数字和为14，可以整除7，输出1。

第二组小明牌的数字为11，再发了10张牌，这10张牌数字和为10，无法整除11，输出0。

## 解题思路

**基本思路：** 如果余数与前几次的余数相同，则表示其中一定存在连续累加为m的数字，可以用于判断。
1. 初始化结果列表。
2. 遍历输入数据：
   - `m`表示发给小明的牌，`pokers`表示后续发的牌。
   - 遍历后续发的牌：
        - 计算累加和与`m`的余数。
        - 如果余数与前几次的余数相同，则表示其中一定存在连续累加为m的数字，返回1。
   - 否则遍历之后都没有，则返回0。
   - 将判断结果存入结果列表中。 
3. 返回结果列表。

## 解题代码

```python
def solve_method(cases):
    result = []
    for case in cases:
        m = case[0]
        pokers = case[1]

        # 累加和
        pre_sum = 0
        is_true = 0
        # 余数集合
        remainders = set()
        for poker in pokers:
            pre_sum = (pre_sum + poker) % m
            # 如果余数与前几次的余数相同，则表示其中一定存在连续累加为m的数字
            if pre_sum in remainders:
                is_true = 1
                break
            remainders.add(pre_sum)

        result.append(is_true)

    return result


if __name__ == '__main__':
    cases = [[7, [4, 4, 2, 5, 3, 5, 5]],
             [11, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]]
    assert solve_method(cases) == [1, 0]
```