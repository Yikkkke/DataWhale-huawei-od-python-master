# 088 招聘

## 题目描述

某公司组织一场公开招聘活动，假设由于人数和场地的限制，每人每次面试的时长不等，并已经安排给定，用`(S1,E1)`、`(S2,E2)`、...、`(Sj,Ej)`，其中`Si`<`Ei`，均为非负整数，表示每场面试的开始和结束时间。

面试采用一对一的方式，即一名面试官同时只能面试一名应试者，一名面试官完成一次面试后可以立即进行下一场面试，且每个面试官的面试人次不超过`m`。为了支撑招聘活动高效顺利进行，请你计算至少需要多少名面试官。

## 输入描述

输入的第一行是面试官的最多面试人次`m`，第二行是当天总的面试场次`n`。

接下来的`n`行是每场面试的起始时间和结束时间，起始时间和结束时间用空格分隔。其中，1<= n,m <= 500。

## 输出描述

输出一个整数，表示至少需要的面试官数量。

## 示例描述

### 示例一

**输入：**
```text
2
5
1 2
2 3
3 4
4 5
5 6
```

**输出：**
```text
3
```

**说明：**  

总共有5场面试，且面试时间都不重叠，但每个面试官最多只能面试2人次，所以需要3名面试官。

### 示例二

**输入：**
```text
3
3
1 2
2 3
3 4
```

**输出：**
```text
1
```

**说明：**  

总共有3场面试，面试时间都不重叠，每个面试官最多能面试3人次，所以只需要1名面试官。

## 解题思路

1. 对面试者面试的起始时间从小到大进行排序。
2. 初始化面试官列表，其中每个元素有两个值，第一个值表示面试官的面试结束时间，第二个值表示面试官的面试次数。
3. 遍历所有面试者：
   - 如果面试官的上一轮的面试结束时间小于当前面试者的开始时间，并且面试次数没有达到m次，则表示可用。
   - 如果存在空闲的面试官，则分配面试。
   - 如果没有空闲，则新增一位面试官。 
4. 返回面试官列表的长度，即需要的面试官个数。

## 解题代码

```python
def solve_method(m, interviews):
    """
    :param m: 面试官的最多面试人次
    :param interviews: 面试时间，每场面试的起始时间和结束时间
    :return:
    """
    interviews.sort(key=lambda x: x[0])
    # 面试官，每个元素有两个值，第一个值表示面试官的面试结束时间，第二个值表示面试官的面试次数
    interviewer = []
    for interview in interviews:
        # 如果面试官的上一轮的面试结束时间小于当前面试者的开始时间，并且面试次数没有达到m次，则表示可用
        interviewer_mask = [True if x[0] <= interview[0] and x[1] < m else False for x in interviewer]
        if any(interviewer_mask):
            # 如果存在空闲的面试官，则分配面试
            i = interviewer_mask.index(True)
            interviewer[i][1] += 1
            interviewer[i][0] = interview[1]
        else:
            # 如果没有空闲，则新增1位面试官
            interviewer.append([interview[1], 1])

    return len(interviewer)


if __name__ == '__main__':
    arr = [[1, 2],
           [2, 3],
           [3, 4],
           [4, 5],
           [5, 6]]
    assert solve_method(2, arr) == 3

    arr = [[1, 2],
           [2, 3],
           [3, 4]]
    assert solve_method(3, arr) == 1
```