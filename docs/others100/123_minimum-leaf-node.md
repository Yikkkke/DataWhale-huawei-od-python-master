# 123 最小叶子节点

## 题目描述

二叉树也可以用数组来存储，给定一个数组，树的根节点的值存储在下标1，对于存储在下标`n`的节点，它的左子节点和右子节点分别存储在下标`2n`和`2n+1`，并且我们用-1代表一个节点为空。

现给定一个数组存储的二叉树，试求从根节点到最小的叶子节点的路径，路径由节点的值组成。

## 输入描述

输入一个数组，数组的每个元素都是正整数，元素间用空格分隔，

注意：第一个元素为根节点的值，即数组的第`n`个元素对应下标为`n`，下标为0在树的表示中没有使用，所以我们省略了，输入的树最多为7层。

## 输出描述

输出从根节点到最小叶子节点的路径上各个节点的值，由空格分隔，用例保证最小叶子节点只有一个。

## 示例描述

### 示例一

**输入：**
```text
3 5 7 -1 -1 2 4
```

**输出：**
```text
3 7 2
```

### 示例二

**输入：**
```text
5 9 8 -1 -1 7 -1 -1 -1 -1 -1 6
```

**输出：**
```text
5 8 7 6 
```

## 解题思路

**基本思路：** 先找到数组中的最小值，再回溯找到路径。
1. 插入下标0的节点，并设置节点值为0。
2. 循环遍历找到最小值，即最小叶子节点。
3. 回溯找到路径：
    - 确定参数：数组`arr`、下标`min_pos`、结果路径`paths`。
    - 将当前节点存入到结果路径中。
    - 终止条件：当回溯到下标为1时，停止回溯。
    - 回溯搜索遍历过程：
        - 当下标能整除2时，即当前节点是上一个节点的左子节点，下标整除2，继续回溯。
        - 当下标不能整除2时，即当前节点是上一个节点的右子节点，下标减一再整除2，继续回溯。
4. 逆序结果路径，并返回。

## 解题代码

```python
import math


def backtracking(arr, min_pos, paths):
    paths.append(arr[min_pos])
    if min_pos == 1:
        return
    if min_pos % 2 == 0:
        # 该节点是上一个节点的左子节点
        backtracking(arr, min_pos // 2, paths)
    else:
        # 该节点是上一个节点的右子节点
        backtracking(arr, (min_pos - 1) // 2, paths)


def solve_method(arr):
    # 插入头节点
    arr.insert(0, 0)

    # 找到最小值，即最小叶子节点
    min_val = math.inf
    min_pos = 0
    for i in range(2, len(arr)):
        val = arr[i]
        # 判断叶子节点：当节点的左子节点的下标索引超出了数组长度，或者节点的左子节点和右子节点均为-1时，是叶子节点
        if val not in [0, -1] and val < min_val and (i * 2 > len(arr) or (arr[2 * i] == -1 and arr[2 * i + 1] == -1)):
            min_val = val
            min_pos = i
    # 回溯，找到路径
    paths = []
    backtracking(arr, min_pos, paths)
    paths.reverse()
    return paths


if __name__ == '__main__':
    assert solve_method([3, 5, 7, -1, -1, 2, 4]) == [3, 7, 2]
    assert solve_method([5, 9, 8, -1, -1, 7, -1, -1, -1, -1, -1, 6]) == [5, 8, 7, 6]
    assert solve_method([3, 5, 7, 6, 7, 2, 4, 9, 8, 14, 13, -1, -1]) == [3, 7, 2]
```