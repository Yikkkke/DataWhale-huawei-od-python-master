# 101 数据最节约的备份方法

## 题目描述

有若干个文件，使用刻录光盘的方式进行备份，假设每张光盘的容量是500MB，求使用的光盘最少的文件分布方式。所有文件的大小都是整数的MB，且不超过500MB，文件不能分割、分卷打包。

## 输入描述

一组文件大小的数据

## 输出描述

使用光盘的数量

## 补充说明

- 不用考虑输入数据不合法的情况，假设最多100个输入文件。
- 输入和输出内容都不含空格。

## 示例描述

### 示例一

**输入：**
```text
100，500，300，200，400
```

**输出：**
```text
3
```

**说明：**  
存储方式为(100,400),(200,300),(500)，只需要3张光盘即可。

### 示例二

**输入：**
```text
100,100,200,300
```

**输出：**
```text
2
```

## 解题思路

**基本思路：** 使用深度优先搜索的方法求解。
1. 将光盘列表按从小到大排序。
2. 使用深度优先搜索遍历光盘列表：
   - 确定参数：光盘列表`arr`、需要光盘数量`num`
   - 终止条件：当如果列表长度小于等于1，返回最小光盘数量和当前光盘列表长度总和。
   - 处理过程：
      - 如果刚好等于500，在光盘列表中删除最大和最小容量光盘 对所需容量加1。
      - 如果大于500，则在光盘列表中删除最大容量光盘，在光盘列表中删除最大。
      - 如果小于500，则把相加值赋给光盘列表中最大容量光盘，再删除光盘列表中最小容量光盘。
      - 继续递归。
3. 返回递归结果，即为最小的光盘数量。

## 解题代码
```python
def dfs(arr, num):
    if len(arr) <= 1:
        num += len(arr)
        return num

    if arr[0] + arr[-1] < 500:
        arr[-1] += arr[0]
        arr.pop(0)
    elif arr[0] + arr[-1] == 500:
        arr.pop()
        arr.pop(0)
        num += 1
    else:
        arr.pop()
        num += 1
    return dfs(arr, num)


def solve_method(arr):
    arr.sort()
    result = dfs(arr, 0)
    return result


if __name__ == '__main__':
    assert solve_method([100, 500, 300, 200, 400]) == 3
    assert solve_method([100, 100, 200, 300]) == 2
```

