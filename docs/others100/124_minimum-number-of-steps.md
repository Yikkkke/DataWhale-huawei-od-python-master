# 124 最小步骤数

## 题目描述

一个正整数数组，设为`nums`，最大为100个成员，按照如下要求，求从第一个成员开始正好走到数组最后一个成员所使用的最小步骤数。

要求：
1. 第1步，必须从第1个元素开始，且1 <= 第1步步长 < len / 2，其中`len`为数组长度。
2. 从第2步开始，只能以所在元素的数字走相应的步数，不能多也不能少，如果目标不可达，返回-1，只输出最小的步骤数。
3. 只能向数组的尾部走，不能向回走。

## 输入描述

输入一个正整数数组，元素用空格分隔，数组长度 < 100。

## 输出描述

输出正整数，表示最小步数，不存在时，输出 -1。

## 示例描述

### 示例一

**输入：**
```text
7 5 9 4 2 6 8 3 5 4 3 9
```

**输出：**
```text
2
```

**说明：**  
第一个可选步长为7，从第一个成员7开始走2步到9，第2步从9经过9个成员，刚好到数组最后一个元素。

### 示例二

**输入：**
```text
1 2 3 7 1 5 9 3 2 1
```

**输出：**
```text
-1
```

## 解题思路

1. 设置最小步数的初始值。
2. 循环遍历第1步可能的走法，遍历范围从1到数组长度的一半。
    - 初始化步数为1，数组位置`index`为`i`。
    - 使用`while`循环，继续以所在元素的数字走相应的步数，继续遍历。
        - 当超过边界时，跳出while循环，继续开始尝试第1步的其他走法。
        - 当正好达到数组最后一个元素时，记录最小步数，继续开始尝试第1步的其他走法。
3. 返回最小步数，如果最小步数仍为初始值，则返回-1，表示不存在。

## 解题代码

```python
import math


def solve_method(nums):
    min_step = math.inf
    n = len(nums)
    for i in range(1, n // 2):
        step = 1
        index = i

        while True:
            # 以所在元素的数字走相应的步数
            index += nums[index]
            step += 1
            if index > n - 1:
                break
            elif index == n - 1:
                min_step = min(min_step, step)
                break

    return -1 if min_step == math.inf else min_step


if __name__ == '__main__':
    assert solve_method([7, 5, 9, 4, 2, 6, 8, 3, 5, 4, 3, 9]) == 2
    assert solve_method([1, 2, 3, 7, 1, 5, 9, 3, 2, 1]) == -1
```