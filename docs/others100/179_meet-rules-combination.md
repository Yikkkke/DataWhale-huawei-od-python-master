# 179 满足规则的组合

## 题目描述

给定一个正整数数组，检查数组中是否存在满足规则的数组组合规则：`A = B + 2C`

## 输入描述

第一行输入数组的元素个数。

接下来一行输入所有数组元素，用空格分隔。

## 输出描述

如果存在满足要求的数，则在同一行里依次输出规则里`A B C`的取值，用空格分隔，如果不存在，则输出0。

**备注：**
- 数组长度在3\~100之间。
- 数组元素为0\~65535。
- 数组元素可以重复。
- 每个成员只能在结果算式中使用一次，如数组成员为`[0,0,1,5]`，其中0出现两次，但结果`0=0+2*0`不允许，因为算式中使用了3个0。
- 用例保证每组数字里最多只有一组符合要求的解。

## 示例描述

### 示例一

**输入：**

```text
4
2 7 3 0
```

**输出：**

```text
7 3 2
```

**说明：**

可以找到满足规则的数组组合：7 = 3 + 2 * 2，故输出`7 3 2`。

### 示例二

**输入：**

```text
3
1 1 1
```

**输出：**

```text
0
```

**说明：** 

找不到满足条件的组合。

## 解题思路

1. 使用`Counter`类构建数字频次字典，`key`为数字，`value`为出现次数。
2. 两层`for`循环，用于得到`a`和`b`的值：
    - 在字典中减去`a`和`b`数字出现次数1次。
    - 计算`a`和`b`的差值`k`。
    - 如果`k`能整除2，并且除数在字典中，则满足规则，返回结果。
    - 回溯：在字典中加上`a`和`b`数字出现次数1次。
    
## 解题代码

```python
from collections import Counter


def solve_method(n, nums):
    num_freq = Counter(nums)

    for i in range(n - 2):
        for j in range(i + 1, n - 1):
            a = nums[i]
            b = nums[j]
            num_freq[a] -= 1
            num_freq[b] -= 1
            k = a - b
            if k % 2 == 0 and k // 2 in num_freq and num_freq[k // 2] > 0:
                return [a, b, (k // 2)]
            num_freq[a] += 1
            num_freq[b] += 1
    return 0


if __name__ == '__main__':
    assert solve_method(4, [2, 7, 3, 0]) == [7, 3, 2]
    assert solve_method(3, [1, 1, 1]) == 0
```



