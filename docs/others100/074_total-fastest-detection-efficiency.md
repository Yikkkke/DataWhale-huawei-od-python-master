# 074 总最快检测效率

## 题目描述

在系统、网络均正常情况下，组织核酸采样员和志愿者对人群进行核酸检测筛查。每名采样员的效率不同，采样效率为`N人/小时`。

由于外界变化，采样员的效率会以`M人/小时`为粒度发生变化，`M`为采样效率浮动粒度，`M=N*10%`，输入保证`N*10%`的结果为整数。采样员效率浮动规则：

采样员需要一名志愿者协助组织才能发挥正常效率，再此基础上，每增加一名志愿者，效率提升`1M`，最多提升`3M`，如果没有志愿者协助组织，效率下降`2M`。

怎么安排速度最快，求总最快检测效率。（总检查效率为各采样人员效率值相加）

## 输入描述

第一行输入是两个整数，分别是采样员人数和志愿者人数，取值范围：1 <= 采样人数 <= 100、1 <= 志愿者人数 <= 500。

第二行输入是采样员基准效率值（单位人/小时），取值范围[60,600]，保证序列中每项值计算10%为整数。

## 输出描述

输出一个整数，总最快检测效率（单位人/小时）。

## 示例描述

### 示例一

**输入：**
```text
2 2
200 200
```

**输出：**
```text
400
```

## 解题思路

1. 遍历所有的采样员：
    - 当有1个志愿者，增加20%；每增加1个志愿者，效率提升10%，最多提升30%。使用数组保存所有的提升效率。
2. 计算当没有志愿者协助时，每个采样员的效率是80%。
3. 选取志愿者能提升效率最高的分配给采样员，计算总和。
4. 返回结果，即总最快检测效率。

## 解题代码

```python
def solve_method(samplers, num_volunteer):
    profit = []
    for p in samplers:
        # 当有1个志愿者，增加20%
        # 每增加1个志愿者，效率提升10%，最多提升30%
        profit.extend([p * 0.2, p * 0.1, p * 0.1, p * 0.1])
    # 没有志愿者协助时，每个采样员的效率是80%
    samplers = [i * 0.8 for i in samplers]
    # 选取志愿者能提升效率最高的分配给采样员，计算总和
    return sum(samplers) + sum(sorted(profit, reverse=True)[:num_volunteer])


if __name__ == '__main__':
    samplers = [200, 200]
    assert solve_method(samplers, 2) == 400
```

