# 025 入栈出栈

## 题目描述

向一个空栈中依次存入正整数，假设入栈元素`N`，取值范围是1 <= N <= 2^31-1。

按顺序依次为`Nx ... N4、N3、N2、N1`，当元素入栈时，如果`N1=N2+...Ny`，其中`y`取值范围是`[2,x] (1 <= x <= 1000)`。则`N1`到`Ny`全部元素出栈，重新入栈新元素`M(M=2*N1)`。

如依次向栈存储`6,1,2,3`，当存储`6,1,2`时，栈底至栈顶以此为`[6、1、2]`；当存入`3`时，由于`3=2+1`，则`3,2,1`全部出栈，重新入栈元素`6(6=2*3)`，此时栈中有元素`6,6`，因为`6=6`，所有两个`6`全部出栈存入`12`，最终栈中只剩一个元素为`12`。

## 输入描述

使用单个空格隔开的正整数的字符串，如`5 6 7 8`，左边的数字先入栈。输入的正整数个数为`x`，取值范围是1 <= x <= 1000。

## 输出描述

最终栈中存留的元素值，元素值使用空格隔开，如`8 7 6 5`，栈顶数字在左边。

## 示例描述

### 示例一

**输入：**

```text
5 10 20 50 85 1
```

**输出：**

```text
1 170
```

**说明：**

当输入85时，由于85=5+10+20+50，所以5、10、20、50全部出栈，入栈170（2*85）。

最终依次出栈的数字为1和170。

### 示例二

**输入：**

```text
6 7 8 13 9
```

**输出：**

```text
9 13 8 7 6
```

### 示例三

**输入：**

```text
1 2 5 7 9 1 2 2
```

**输出：**

```text
4 1 9 14 1
```

## 解题思路

1. 初始化用于存储的栈`stack`。
2. 遍历所有待入栈的元素：
    - 初始化`changed`标识，表示是否重新入栈新元素。
    - 从后向前遍历栈内元素：如果满足`N1=N2+...+Ny`，则出栈该范围的元素，入栈新元素。
    - 如果不满足条件，则继续入栈元素。
3. 返回结果，即栈的逆序排列。

## 解题代码

```Python
def solve_method(nums):
    stack = []

    for num in nums:
        # 标识是否重新入栈新元素
        changed = False
        if stack:
            i = n = len(stack) - 1

            while i > -1:
                # 当满足条件时，出栈相应元素，入栈新元素
                if sum(stack[i:n + 1]) == num:
                    del stack[i:n + 1]
                    stack.insert(i, num * 2)
                    changed = True
                    break
                i -= 1
        if not changed:
            stack.append(num)

    return stack[::-1]


if __name__ == '__main__':
    nums = [5, 10, 20, 50, 85, 1]
    assert solve_method(nums) == [1, 170]

    nums = [6, 7, 8, 13, 9]
    assert solve_method(nums) == [9, 13, 8, 7, 6]

    nums = [1, 2, 5, 7, 9, 1, 2, 2]
    assert solve_method(nums) == [4, 1, 9, 14, 1]
```

