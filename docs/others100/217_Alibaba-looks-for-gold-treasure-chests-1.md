# 217 阿里巴巴找黄金宝箱（1）

## 题目描述

一贫如洗的樵夫阿里巴巴在去砍柴的路上，无意中发现了强盗集团的藏宝地，藏宝地有编号从0\~N的箱子，每个箱子上面贴有一个数字，箱子中可能有一个黄金宝箱。

黄金宝箱的满足条件：排在它之前的所有箱子数字和等于排在它之后的所有箱子数字和。其中第1个箱子左边部分的数字和定义为0，最后1个箱子右边部分的数字和定义为0。

请帮助阿里巴巴找到黄金宝箱，输出第一个满足条件的黄金宝箱编号，如果不存在，请返回-1。

## 输入描述

箱子上贴的数字列表，数字之间使用`,`分隔，例如
```text
2,5,-1,8,6
```

宝箱的数量不小于1个，不超过1000，宝箱上贴的数字范围不低于-1000，不超过1000。

## 输出描述

输出第一个黄金宝箱的编号。

## 示例描述

### 示例一

**输入：**
```text
2,5,-1,8,6
```

**输出：**
```text
3
```

**说明：**  
下标3之后的数字和为6，等于左侧所有的数字和6。

### 示例二

**输入：**
```text
8,9
```

**输出：**
```text
-1
```

**说明：**  
不存在符合要求的位置。

### 示例三

**输入：**
```text
11
```

**输出：**
```text
0
```

**说明：**  
下标0之前的数字和为0，之后的数字和为0。

## 解题思路

1. 初始化左侧数字和、右侧数字和。
2. 遍历宝箱数组：
   - 每次遍历将右侧数字和减去当前数字
   - 如果满足左侧数字和等于右侧数字和，则返回坐标。
   - 如果不满足，则将左侧数字和加上当前数字。 
3. 如果不存在，返回-1。

## 解题代码

```python
def solve_method(nums):
    left_sum = 0
    right_sum = sum(nums)
    for i in range(len(nums)):
        # 每次遍历将右侧数字和减去当前数字
        right_sum -= nums[i]
        if left_sum == right_sum:
            # 如果满足相等条件，则返回坐标
            return i
        # 每次遍历将左侧数字和加上当前数字
        left_sum += nums[i]

    # 如果不存在，返回-1
    return -1


if __name__ == '__main__':
    assert solve_method([2, 5, -1, 8, 6]) == 3
    assert solve_method([8, 9]) == -1
    assert solve_method([11]) == 0
```