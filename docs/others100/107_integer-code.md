# 107 整数编码

## 题目描述

实现一个整数编码方法，使得待编码的数字越小，编码后所占用的字节数越小。

编码规则如下：

1. 编码是7位一组，每个字节的低7位用于存储待编码数字的补码。
2. 字节的最高位表示后续是否还有字节，置1表示后面还有更多的字节，置0表示当前字节为最后一个字节。
3. 采用小端序编码，低位和低字节放在低地址上。
4. 编码结果按16进制数的字符格式进行输出，小写字母需要转化为大写字母。

## 输入描述

输入一个字符串表示的非负整数。

## 输出描述

输出一个字符串表示整数编码的16进制码流。

## 示例描述

### 示例一

**输入：**

```text
0
```

**输出：**

```text
00
```

**说明：**

输出的16进制字符不足两位的前面补零。

### 示例二

**输入：**

```text
100
```

**输出：**

```text
64
```

**说明：**

100的二进制表示为`0110 0100`，只需一个字节进行编码，字节的最高位0，剩余7位存储数字，100的低7位是`1100100`，所以编码后的输出为64。

### 示例三

**输入：**

```text
1000
```

**输出：**

```text
E807
```

**说明：**

1000的二进制表示为`0011 1110 1000`，至少需要两个字节进行编码。

- 第一个字节最高位是1，剩余7位存储数字`1000`的低7位是`1101000`，所以第一个字节的二进制是`1110 1000`，即`E8`。
- 第二个字节最高位置0，剩余7位存储数字`1000`的第二个低7位是`0000111`，所以第一个字节的二进制是`0000 0111`，即`07`。

采用小端序编码，所以低字节`E8`输出在前面，高字节`07`输出在后面。

**备注：**

待编码数字取值范围为`[ 0, 1 << 64 - 1 ]`

## 解题思路

**基本思路：** 将一个十进制数转换成二进制后，分段转换为十六进制。

1. 使用`bin()`方法将十进制数转换为二进制字符串。
2. 遍历二进制字符串，每7位分为一段：
    - 如果当前段的长度不足7位，使用`zfill`方法在前面补0。
    - 将当前段的第一位置为0或1，代表最高位的符号位
    - 将二进制转成十六进制，并转成大写字母，然后位数不够2位在前面补0。
    - 将十六进制数拼接起来，存入结果字符串中。
3. 返回最终的十六进制字符串。

## 解题代码

```python
def solve_method(num):
    # 得到二进制
    binary = bin(num)[2:]
    length = len(binary)
    result = ""
    # 从后向前，每7位遍历一次
    for i in range(length, 0, -7):
        start = max(i - 7, 0)
        bin_7bit = binary[start:i]
        # 位数不够7位左侧补0
        bin_7bit = bin_7bit.zfill(7)
        # 置1表示后面还有更多的字节，置0表示当前字节为最后一个字节
        bin_7bit = "0" + bin_7bit if i - 7 <= 0 else "1" + bin_7bit
        # 将二进制转成十六进制，并转成大写字母，然后位数不够2位，左边补0
        hex_7bit = hex(int(bin_7bit, 2)).upper()[2:].zfill(2)
        result += hex_7bit

    return result


if __name__ == "__main__":
    assert solve_method(0) == '00'
    assert solve_method(100) == '64'
    assert solve_method(1000) == 'E807'
```