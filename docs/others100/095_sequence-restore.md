# 095 数列还原

## 题目描述

有一个数列`A[n]`，从`A[0]`开始每一项都是一个数字，数列中`A[n+1]`都是`A[n]`的描述，其中`A[0]=1`，规则如下：
- `A[θ]:1`
- `A[1]:11`含义是，`A[0]=1`是1个1（即11），表示`A[0]`从左到右连续出现了1次1。
- `A[2]:21`含义是，`A[1]=11`是2个1（即21），表示`A[1]`从左到右连续出现了2次1。
- `A[3]:1211`含义是，`A[2]`从左到右是由一个2和一个1组成（即1211），表示`A[2]`从左到右连续出现了1次2又连续出现了1次1。
- `A[4]:111221`含义是，`A[3]=1211`从左到右是由一个1和一个2两个1（即111221），表示`A[3]`从左到右连续出现了1次1又连续出现了1次2又连续出现了2次1。

根据上述规则，请输出第`n`项的结果。

## 输入描述

数列第`n`项，取值范围是0 <= n <= 59。

## 输出描述

输出第`n`项的结果。

## 示例描述

### 示例一

**输入：**
```text
4
```

**输出：**
```text
111221
```

## 解题思路

1. 第0项时，`prev_chars`结果为1，用于存储前一项。
2. 从第2项开始生成：
   - 计数器`count`初始化为1，用于记录有多少个数字。
   - 对前一项的数进行描述：
        - 如果当前数字与前一个数字相同，计数器加1。
        - 如果不相同，将计数和数字添加到描述中，重置计数器为1。
   - 处理最后一个数字，得到前一个数的描述。
   - 将描述保存到prev_chars变量中。 
3. 返回结果。

## 解题代码

```python
def solve_method(n):
    prev_chars = "1"

    # 从第2项开始生成
    for _ in range(1, n + 1):
        # 获取前一项
        current = prev_chars
        # 计数器初始化为1
        count = 1
        description = ""

        for i in range(1, len(current)):
            if current[i] == current[i - 1]:
                # 如果当前数字与前一个数字相同，计数器加1
                count += 1
            else:
                # 将计数和数字添加到描述中，重置计数器为1
                description += str(count) + current[i - 1]
                count = 1

        # 处理最后一个数字，得到前一个数的描述
        description += str(count) + current[-1]
        # 将描述保存到prev_chars变量中
        prev_chars = description
    
    return prev_chars


if __name__ == '__main__':
    assert solve_method(0) == "1"
    assert solve_method(4) == "111221"
```