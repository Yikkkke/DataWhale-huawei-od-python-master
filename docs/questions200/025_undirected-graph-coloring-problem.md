# 025 无向图染色问题、红黑图

## 题目描述

众所周知红黑树是一种平衡树，它最突出的特性就是不能有两个相邻的红色节点。那我们定义一个红黑图，也就是一张无向图中，每个节点可能有红黑两种颜色，但我们必须保证没有两个相邻的红色节点。

现在给出一张未染色的图，只能染红黑两色，问总共有多少种染色方案使得它成为一个红黑图。

## 输入描述

第一行两个数字`n`、`m`，表示图中有`n`个节点和`m`条边。

接下来共计`m`行，每行两个数字`s`、`t`，表示一条连接节点`s`和节点`t`的边，节点编号取值范围是[0,n)。

## 输出描述

一个数字表示总的染色方案数。

## 说明

- 0 < n < 15
- 0 <= m <= n*3
- 0 <= s,t < n
- 不保证图连通。
- 保证没有重边和自环。

## 示例描述

### 示例一

**输入：**
```text
3 3
0 1
0 2
1 2
```

**输出：**
```text
4
```

### 示例二

**输入：**
```text
4 3
0 1
1 2
2 3
```

**输出：**
```text
8
```

## 解题思路

**基本思路：**

考虑到本题只染红黑两色，且相邻结点不允许同时染红色，思考其他解法：
- 将`n`个节点摆放在各个数位上，将染色比拟成二进制0和1（黑色为0，红色为1）。
- 若不考虑相邻结点不允许同时染红色：对于`n`个数字，共有`2^n`种染色方案。
- 若考虑相邻结点不允许同时染红色：枚举各个方案，若`s`和`t`数字相连，判断是否两数位上都为1。若都为1，则排除掉该方案。

**代码思路：**
1. 外层循环遍历`2^n`种方案。
      - 内层循环枚举可能相连的两节点，判定两节点所在的数位是否都为1。
         - 若都为1，说明该方案不合要求（跳出内层循环）
2. 累计符合要求的方案数量，并返回结果。

## 解题代码
```python
def solve_method(n, m, edges):
    count = 0
    for num in range(1 << n):
        # 标记是否满足要求
        flag = True
        for edge in edges:
            if (num & (1 << edge[0])) and (num & (1 << edge[1])):
                flag = False
                break
        count += flag
    return count

if __name__ == "__main__":
    # 3 3
    # 0 1
    # 0 2
    # 1 2
    # n个节点，m条边
    # n, m = map(int, input().split())
    # edges = []
    # for _ in range(m):
    #     edges.append(list(map(int, input().split())))
    # print(solve_method(n, m, edges))
    assert solve_method(3, 3, [[0,1], [0,2], [1,2]]) == 4
    assert solve_method(4, 3, [[0,1], [1,2], [2,3]]) == 8
```