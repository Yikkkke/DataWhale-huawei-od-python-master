# 026 最优资源分配

## 题目描述

某块业务芯片最小容量单位为`1.25G`，总容量为`M * 1.25G`，对该芯片资源编号为`1,2, ..., M`。该芯片支持3种不同的配置，分别为`A`、`B`、`C`。
- 配置`A`：占用容量为`1.25 * 1 = 1.25G`。
- 配置`B`：占用容量为`1.25 * 2 = 2.5G`。
- 配置`C`：占用容量为`1.25 * 8 = 10G`。

某块板卡上集成了`N`块上述芯片，对芯片编号为`1,2,...,N`，各个芯片之间彼此独立，不能跨芯片占用资源。给定板卡上芯片数量`N`、每块芯片容量`M`、用户按次序配置后，请输出芯片资源占用情况，保证消耗的芯片数量最少。

- 资源分配规则：按照芯片编号从小到大分配所需资源，芯片上资源如果被占用标记为1，没有被占用标记为0。
- 用户配置序列：用户配置是按次序依次配置到芯片中，如果用户配置序列中某个配置超过了芯片总容量，丢弃该配置，继续遍历用户后续配置。

**备注：**

用户配置是按次序依次配置到芯片中，如果用户配置序列中某个配置超过了芯片总容量，丢弃该配置，继续遍历用户后续配置。

## 输入描述

第一行是`M`：每块芯片容量为`M * 1.25G`，取值范围为1\~256。

第二行是`N`：每块板卡包含芯片数量，取值范围为1\~32。

第三行是用户配置序列：例如`ACABA`，长度不超过1000。

## 输出描述

板卡上每块芯片的占用情况。

## 示例描述

### 示例一

**输入：**
```text
8
2
ACABA
```

**输出：**
```text
11111000
11111111
```

**说明：**

用户第1个配置`A`：占用第1块芯片第1个资源，芯片占用情况为：
```text
10000000
00000000
```
用户第2个配置`C`：第1块芯片剩余8.75G，配置C容量不够，只能占用第2块芯片，芯片占用情况为：
```text
10000000
11111111
```
用户第3个配置`A`：第1块芯片剩余8.75G，还能继续配置，占用第1块芯片第2个资源，芯片占用情况为：
```text
11000000
11111111
```
用户第4个配置`B`：第1块芯片剩余7.5G，还能继续配置，占用第1块芯片第3/4个资源，芯片占用情况为：
```text
11110000
11111111
```
用户第5个配置`A`：第1块芯片剩余5G，还能继续配置，占用第1块芯片第5个资源，芯片占用情况为：
```text
11110000
11111111
```

### 示例二

**输入：**
```text
8
2
ACBCB
```

**输出：**
```text
11111000
11111111
```

**说明：**

用户第1个配置`A`：占用第1块芯片第1个资源，芯片占用情况为：
```text
10000000
00000000
```
用户第2个配置`C`：第1块芯片剩余8.75G，配置C容量不够，只能占用第2块芯片，芯片占用情况为：
```text
10000000
11111111
```
用户第3个配置`B`：第1块芯片剩余8.75G，还能继续配置，占用第1块芯片第2、3个资源，芯片占用情况为：
```text
11100000
11111111
```
用户第4个配置`C`：芯片资源不够，丢弃配置配置，继续下一个配置，本次配置后芯片占用情况保持不变：
```text
11100000
11111111
```
用户第5个配置`B`：第1块芯片剩余6.25G，还能继续配置，占用第1块芯片第4、5个资源，芯片占用情况为：
```text
11111000
11111111
```

## 解题思路

1. 遍历所有用户配置：
   - 遍历各个芯片的容量，判定是否满足用户配置：
       - 若满足用户配置，当前芯片容量减去需要的配置数，并跳出循环，继续遍历下一个用户配置。
       - 若不满足用户配置，继续遍历下一个芯片，直到找不到，舍弃该配置。
2. 按照芯片容量格式，返回对应的结果。

## 解题代码
```python
def solve_method(M, N, config):
    cores = [M] * N
    used = [1, 2, 8]
    for c in config:
        cur = used[ord(c) - ord('A')]
        # 资源分配规则：按芯片编号从小到大分配资源
        for i in range(N):
            # 当前芯片容量，满足用户配置
            if cores[i] >= cur:
                cores[i] -= cur
                break
    return ['1' * (M - core) + '0' * core for core in cores]

if __name__ == "__main__":
    # 8
    # 2
    # ACABA
    M = int(input())
    N = int(input())
    config = input().strip()
    for core in solve_method(M, N, config):
        print(core)
    assert solve_method(8, 2, "ACABA") == ["11111000", "11111111"]
    assert solve_method(8, 2, "ACBCB") == ["11111000", "11111111"]
```