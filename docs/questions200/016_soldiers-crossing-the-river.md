# 016 士兵过河

## 题目描述

一支`N`个士兵的军队正在趁夜色逃亡，途中遇到一条湍急的大河。敌军在`T`的时长后到达河面，没到过对岸的士兵都会被消灭。现在军队只找到了一只小船，这船最多能同时坐上2个士兵。

1. 当1个士兵划船过河，用时为`a[i]`，其中0 <= i < N。
2. 当2个士兵坐船，同时划船过河时，用时为`max(a[j], a[i])`，两士兵中用时最长的。
3. 当2个士兵坐船，只有一个士兵划船时，用时为`a[i] * 10`，其中`a[i]`为划船士兵用时。
4. 如果士兵下河游泳，则会被湍急水流直接带走，算作死亡。

请帮忙给出一种解决方案，保证存活的士兵最多，且过河用时最短。

**备注**

1. 两个士兵同时划船时，如果划速不同会导致船原地转圈圈；所以为保持两个士兵划速相同，则需要向划的慢的士兵看齐。
2. 两个士兵坐船时，重量增加吃水加深，水的阻力增大；同样的力量划船速度会变慢。
3. 由于河水湍急大量的力用来抵消水流的阻力，所以在第3个情况下，过河时间不是`a[i] * 2`，而是`a[i] * 10`。

## 输入描述

第一行是`N`，表示士兵数，取值范围是0 < N < 1000000。

第二行是`T`，表示敌军到达时长，取值范围是0 < T < 100000000。

第三行是`a[0] a[1] … a[i] … a[N - 1]`，表示所有士兵划船的时间序列，其中`a[i]`表示每个士兵的过河时长，取值范围是10 < a[i] < 100、0 < i < N。

## 输出描述

保证存活的士兵最多的过河最短用时。

## 示例描述

### 示例一

**输入：**
```text
5
43
12 13 15 20 50
```

**输出：**
```text
3 40
```

**说明：** 

可以达到或小于43的一种方案：

- 第1步：过河士兵是第1个和第2个，分别用时为`a[0] a[1]`，过河用时是13。
- 第2步：第1个士兵划船返回，用时是`a[0]`，即返回用时是12。
- 第3步：过河士兵是第1个和第3个，分别用时为`a[0] a[2]`，过河用时是15。

所以，最多存活士兵有3个，过河用时是13+12+15=40。

### 示例二

**输入：**
```text
5
130
50 12 13 15 20
```

**输出：**
```text
5 128
```

**说明：** 

可以达到或小于130的一种方案：

- 第1步：过河士兵是第2个和第3个，分别用时为`a[1] a[2]`，过河用时是13。
- 第2步：第2个士兵划船返回，用时是`a[1]`，即返回用时是12。
- 第3步：过河士兵是第1个和第5个，分别用时为`a[0] a[4]`，过河用时是50。
- 第4步：第3个士兵划船返回，用时是`a[2]`，即返回用时是13。
- 第5步：过河士兵是第2个和第3个，分别用时为`a[1] a[2]`，过河用时是13。
- 第6步：第2个士兵划船返回，用时是`a[1]`，即返回用时是12。
- 第7步：过河士兵是第2个和第4个，分别用时是`a[1] a[3]`，过河用时是15。

所以，最多存活士兵有5个，过河用时是13+12+50+13+13+12+15=128。

### 示例三

**输入：**
```text
7
171
25 12 13 15 20 35 20
```

**输出：**
```text
7 171
```

**说明：** 

可以达到或小于171的一种方案：

- 第1步：过河士兵是第2个和第3个，分别用时为`a[1] a[2]`，过河用时是13。
- 第2步：第2个士兵划船返回，用时是`a[1]`，即返回用时是12。
- 第3步：过河士兵是第1个和第6个，分别用时为`a[0] a[5]`，过河用时是35。
- 第4步：第3个士兵划船返回，用时是`a[2]`，即返回用时是13。
- 第5步：过河士兵是第2个和第3个，分别用时为`a[1] a[2]`，过河用时是13。
- 第6步：第2个士兵划船返回，用时是`a[1]`，即返回用时是12。
- 第7步：过河士兵是第5个和第7个，分别用时为`a[4] a[6]`，过河用时是20。
- 第8步：第3个士兵划船返回，用时是`a[2]`，即返回用时是13。
- 第9步：过河士兵是第2个和第4个，分别用时为`a[1] a[3]`，过河用时是15。
- 第10步：第2个士兵划船返回，用时是`a[1]`，即返回用时是12。
- 第11步：过河士兵是第2个和第3个，分别用时为`a[1] a[2]`，过河用时是13。

所以，最多存活士兵有7个，过河用时是13+12+35+13+13+12+20+13+15+12+13=171。


## 解题思路

**基本思路：** 使用动态规划求解。

1. 将所有士兵的过河时长从小到大排序。
2. 使用动态规划方法：
    - 确定dp数组以及下标的含义：`dp[i]`表示存活i人的最短过河时间。
    - 确定递推公式：
        - 仅剩最后一人未过河的情况，让耗时最少的人划船返回，再计算两人划船过河的时长：`dp[i - 1] + arr[0] + shorter_time(arr[0], arr[i])`。
        - 剩两人的情况，需要来回两趟，需要a[0]和a[1]分别划船回来一次，再最后一起划船过河：`dp[i - 2] + arr[0] + shorter_time(arr[i - 1], arr[i]) + arr[1] + shorter_time(arr[0], arr[1])`。
        - `dp[i]`以上两个时长中更短的那个时长。
    - dp数组如何初始化：
        - `dp[0]`表示为没有人能在敌军到达前过河。
        - `dp[1]`表示可存活1人，一人划船与两人一起划船时长最小值。
    - 确定遍历顺序：从前先后。
3. 当`dp[i]`超过了敌军到来的时长，则`dp[i-1]`的时长作为结果返回。

## 解题代码
```python
def shorter_time(a, b):
    # 返回是一人划船 或 两人一起划船 耗时少的时间
    return a * 10 if a * 10 < b else b


def solve_method(N, T, arr):
    # 将过河时长从小到大排序
    arr.sort()
    # dp[i]表示存活i人的最短过河时间
    dp = [0] * N

    if arr[0] > T:
        # 没有人能在敌军到达前过河
        return 0, 0
    else:
        dp[0] = arr[0]
        if N > 1:
            dp[1] = shorter_time(arr[0], arr[1])
            if dp[1] > T:
                # 两个人无法在敌军到达前完成过河
                return 1, dp[0]
            else:
                # 继续计算更多人需要过河的时长
                for i in range(2, N):
                    # 仅剩最后一人未过河的情况，让耗时最少的人划船返回，再计算两人划船过河的时长
                    a1 = dp[i - 1] + arr[0] + shorter_time(arr[0], arr[i])
                    # 剩两人的情况，需要来回两趟，需要a[0]和a[1]分别划船回来一次，再最后一起划船过河
                    a2 = dp[i - 2] + arr[0] + shorter_time(arr[i - 1], arr[i]) + arr[1] + shorter_time(arr[0], arr[1])
                    # 记录以上两个时长中更短的那个时长
                    dp[i] = min(a1, a2)
                    if dp[i] > T:
                        return i, dp[i - 1]
    return N, dp[N - 1]


if __name__ == '__main__':
    arr = [12, 13, 15, 20, 50]
    assert solve_method(5, 43, arr) == (3, 40)

    arr = [50, 12, 13, 15, 20]
    assert solve_method(5, 130, arr) == (5, 128)

    arr = [25, 12, 13, 15, 20, 35, 20]
    assert solve_method(7, 171, arr) == (7, 171)
```