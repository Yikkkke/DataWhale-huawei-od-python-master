# 027 最佳对手

## 题目描述

游戏里面，队伍通过匹配实力相近的对手进行对战。但是如果匹配的队伍实力相差太大，对于双方游戏体验都不会太好。 给定 n 个队伍的实力值，对其进行两两实力匹配，两支队伍实力差距在允许的最大差距 d 内，则可以匹配。

要求在匹配队伍最多的情况下，匹配出的各组实力差距的总和最小。

## 输入描述

第一行输入是`n`、`d`。`n`表示队伍个数，`d`表示允许的最大实力差距，取值范围是2 <= n <= 50, 0 <= d <= 100。

第二行输入是`n`个队伍的实力值，用空格分隔，取值范围是0 <= 各队伍实力值 <= 100。

## 输出描述

匹配后，各组对战的实力差值的总和。若没有队伍可以匹配，则输出-1。

## 示例描述

### 示例一

**输入：**
```text
6 30
81 87 47 59 81 18
```

**输出：**
```text
57
```

**说明：**
各队伍的匹配情况如下：
- 18与47匹配，实力差距29。
- 59与81匹配，实力差距22。
- 81与87匹配，实力差距6。

总实力差距29+22+6=57。

### 示例二

**输入：**
```text
6 20
81 87 47 59 81 18
```

**输出：**
```text
12
```

**说明：**

最多能匹配成功4支队伍：
- 47与59匹配，实力差距12。
- 81与81匹配，实力差距0。

总实力差距12+0=12。

### 示例三

**输入：**
```text
4 10
40 51 62 73
```

**输出：**
```text
-1
```

**说明：**

实力差距都在10以上，没有队伍可以匹配成功。

## 解题思路

**基本思路：**

看到最大最小等关键词，考虑动态规划。

题目有三点要求：
1. 实力差距在可允许范围内：首先将队伍按实力排序
2. 匹配队伍尽可能多：定义`dp1[i]`表示前`i`个队伍中，最多可以匹配的队伍数量
3. 实力差值总和最小：定义`dp2[i]`表示前`i`个队伍中，最多匹配的队伍数量对应的实力差值总和

**代码思路：**

1. 将队伍按实力从小到大排序。
2. dp1[i]的递推公式：考虑当前队伍 i 和前一个队伍能否匹配。
    - 若能匹配 dp1[i] = max(dp1[i-2] + 1, dp1[i-1])
    - 若不能匹配 dp1[i] = dp1[i-1]
3. dp2[i]的递推公式：考虑当前队伍 i 和前一个队伍能否匹配。
    - 若能匹配
        - 若dp1[i-2] + 1 > dp1[i-1]，dp2[i] = dp2[i-2] + 当前队伍与前一队伍的实力差值
        - 若dp1[i-2] + 1 < dp1[i-1]，dp2[i] = dp2[i-1] 
        - 若dp1[i-2] + 1 == dp1[i-1]，dp2[i] = min(dp2[i-2] + 当前队伍与前一队伍的实力差值, dp2[i-1])
    - 若不能匹配 dp2[i] = dp2[i-1]
4. 返回第`n`个队伍匹配时，最小的实力差值总和。

## 解题代码
```python
def solve_method(n, d, nums):
    nums.sort()
    # 前i个队伍中，最多可以匹配的队伍数量
    dp1 = [0] * (n + 1)
    # 前i个队伍中，最多匹配的队伍数量对应的实力差值总和
    dp2 = [0] * (n + 1)
    for i in range(2, n + 1):
        # 考虑当前队伍i-1是否和前一个队伍匹配
        diff = nums[i - 1] - nums[i - 2]
        if diff <= d:  # 匹配
            # 判断dp1[i]的取值
            if dp1[i - 2] + 1 > dp1[i - 1]:
                dp1[i] = dp1[i - 2] + 1
                dp2[i] = dp2[i - 2] + diff
            elif dp1[i - 2] + 1 < dp1[i - 1]:
                dp1[i] = dp1[i - 1]
                dp2[i] = dp2[i - 1]
            else:
                dp1[i] = dp1[i - 1]
                dp2[i] = min(dp2[i - 2] + diff, dp2[i - 1])
    if dp1[n] == 0:
        return -1
    min_diff_sum = dp2[n]
    return min_diff_sum


if __name__ == "__main__":
    assert solve_method(6, 30, [81, 87, 47, 59, 81, 18]) == 57
    assert solve_method(6, 20, [81, 87, 47, 59, 81, 18]) == 12
    assert solve_method(4, 10, [40, 51, 62, 73]) == -1
```