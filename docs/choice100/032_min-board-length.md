# 032 最短木板长度

## 题目描述

小明有`n`块木板，第`i`块木板长度为`a[i]`，其中1 <= i <= n。小明买了一块长度为`m`的木料，这块木料可以切割成任意块，拼接到已有的木板上，用来加长木板。小明想让最短的木板尽量长。请问小明加长木板后，最短木板的长度可以为多少？

## 输入描述

输入的第一行包含两个正整数`n`和`m`，`n`表示木板数，`m`表示木板长度。其中1 <= n <= 10^3、1 <= m <= 10^6。

输入的第二行包含`n`个正整数，分别为[a1,a2,...,an]，其中1 <= a[i] <= 10^6。

## 输出描述

输出的唯一一行包含一个正整数，表示加长木板后，最短木板的长度最大可以为多少？

## 示例描述

### 示例一

**输入：**

```text
5 3
4 5 3 5 5
```

**输出：**
```text
5
```

**说明：** 

给第1块木板长度增加1，给第3块木板长度增加2后，这5块木板长度变为[5,5,5,5,5]，最短的木板的长度最大为5。

### 示例二

**输入：**
```text
5 2
4 5 3 5 5
```

**输出：**
```text
4
```

**说明：**  

给第3块木板长度增加1后，这5块木板长度变为[4,5,4,5,5]，剩余的木料长度为1。

此时剩余木料无论给哪块木板加长，最短木料的长度都为4。

## 解题思路

1. 对所有木板进行排序。
2. 遍历木料的长度：
    - 补上最短的。
    - 如果当前依然是最短的，则继续让最短的加1。
    - 如果后面那个更短，则向后比较，继续遍历。
3. 返回最短的木板长度。    

## 解题代码

```python
def solve_method(m, A):
    N = len(A)
    A.sort()
    i = 0
    for j in range(m):
        # 补上最短的
        A[i] += 1
        if i == (N - 1) or A[i + 1] >= A[i]:
            # 如果当前依然是最短的，则继续让最短的加1
            i = 0
        else:
            # 如果后面那个更短，则向后比较
            i += 1
    return sorted(A)[0]


if __name__ == '__main__':
    assert solve_method(3, [4, 5, 3, 5, 5]) == 5
    assert solve_method(2, [4, 5, 3, 5, 5]) == 4
    assert solve_method(10, [4, 5, 5, 5, 5]) == 6
```