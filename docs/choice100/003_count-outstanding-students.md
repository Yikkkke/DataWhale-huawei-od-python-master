# 003 优秀学员统计

## 题目描述

公司某部门软件教导团正在组织新员工每日打卡学习活动，他们开展这项学习活动已经一个月了，所以想统计一下这个月优秀的打卡员工。每个员工对应一个id，每天的打卡记录当天打卡的员工的id集合，一共30天。

请你实现代码，帮助统计出打卡次数top5的员工，假如打卡次数相同，将较早参与打卡的员工排在前面，如果开始参与打卡的时间还是一样的，将id较小的员工排在前面。

注：不考虑并列的情况，按规则返回前5名员工id即可，如果当月打卡的员工小于5个，按规则排序返回所有有打卡记录的员工id。

## 输入描述

- 第一行输入为新员工数量`N`，表示新员工编号为0到`N-1`，`N`的范围为[1,100]
- 第二行输入为30个整数，表示每天打卡的员工数量，每天至少有1名员工打卡
- 之后30行表示每天打开的员工id集合，id不会重复

## 输出描述

按顺序输出打卡top5员工的id，用空格隔开

**备注：** 同一天打卡的员工没有时间上早晚的区别，不保证所有员工都会打卡，排名只针对有打卡记录的员工。

## 示例描述

### 示例一

**输入：**
```text
11
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2
0 1 7 10
0 1 6 10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
6 10
7 10
```

**输出：**
```text
10 0 1 7 6
```

**说明：**    
员工编号范围为0\~10，id为10的员工连续打卡30天，排在第一位，id为0、1、6、7的员工打卡都是2天，id为0、1、7的员工在第一天就打卡了，比id为6的员工早，排在前面，id为0、1、7的员工按照id升序排列，所以输出为[10,0,1,7,6]

### 示例二

**输入：**
```text
7
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
```

**输出：**
```text
0 1 2 3 4
```

**说明：**    
员工编号范围为0\~6，id为0、1、2、3、4、5的员工打卡次数先沟通，最早打卡的时间也一样，所以按id升序返回前5个id，所以输出为[0,1,2,3,4]

### 示例三

**输入：**
```text
2
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0 1
0 1
```

**输出：**
```text
1 0
```

**说明：**    
只有两名员工参与打卡，按规则排序输出两名员工的id。

## 解题思路

1. 本题突破点在于构造一个员工打卡记录的字典，可设置`key`表示员工编号，`value`是一个元组，元组第一个数表示打卡次数，元组第二个数表示第一次打卡的时间
2. 遍历30天每天打卡的员工id集合`card_records`，按照上述字典，记录员工打卡次数和第一次打卡的时间
3. 对字典进行`value`值的排序，首先按照打卡次数排序，然后再按照第一次打卡的时间排序，最后默认按照员工id排序
4. 取出前5个员工编号

## 解题代码

```python
def solve_method(N, card_total, card_records):
    """
    :param N: 新员工数量
    :param card_total: 每天打卡的员工数量
    :param card_records: 30天每天打卡的员工id集合
    :return:
    """
    # key表示员工编号
    # value是一个元组，元组第一个数表示打卡次数，元组第二个数表示第一次打卡的时间
    card_dict = {}
    for day, item in enumerate(card_records):
        for p_id in item:
            if p_id in card_dict.keys():
                value = card_dict.get(p_id)
                count = value[0]
                card_dict[p_id] = (count + 1, value[1])
            else:
                card_dict[p_id] = (1, day + 1)

    # 首先按照打卡次数排序，然后再按照第一次打卡的时间排序，最后默认按照id排序
    sorted_card_dict = sorted(card_dict.items(), key=lambda x: (-x[1][0], x[1][1]))

    return [n[0] for n in sorted_card_dict[:5]]

if __name__ == '__main__':
    N = 11
    card_total = [4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2]
    card_records = [[0, 1, 7, 10],
                    [0, 1, 6, 10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [10],
                    [6, 10],
                    [7, 10]]
    assert solve_method(N, card_total, card_records) == [10, 0, 1, 7, 6]

    N = 7
    card_total = [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
    card_records = [
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5]
    ]
    assert solve_method(N, card_total, card_records) == [0, 1, 2, 3, 4]

    N = 2
    card_total = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2]
    card_records = [
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [1],
        [0, 1],
        [0, 1]
    ]
    assert solve_method(N, card_total, card_records) == [1, 0]
```