# 031 最左侧冗余覆盖子串

## 题目描述

给定两个字符串`s1`和`s2`和正整数`k`，其中`s1`长度为`n1`，`s2`长度为`n2`，在`s2`中选一个子串，满足：
1. 该子串长度为`n1+k`。
2. 该子串中包含`s1`中全部字母。
3. 该子串每个字母出现次数不小于`s1`中对应的字母。
   
我们称`s2`以长度`k`冗余覆盖`s1`。

给定`s1`、`s2`、`k`，求最左侧的`s2`以长度`k`冗余覆盖`s1`的子串的首个元素的下标，如果没有返回-1。

## 输入描述

输入三行，第一行是`s1`，第二行是`s2`，第三行是`k`，其中`s1`和`s2`只包含小写字母。

## 输出描述

最左侧的`s2`以长度`k`冗余覆盖`s1`的子串首个元素下标，如果没有返回-1。

## 示例描述

### 示例一

**输入：**

```text
ab
aabcd
1
```

**输出：**

```text
0
```

### 示例二

**输入：**

```text
abc
dfs
10
```

**输出：**

```text
-1
```

## 解题思路

**基本思路：** 使用`Counter`数据结构解题。
1. 对`s1`使用`Counter`，得到词频统计`c1`。
2. 滑动窗口的长度是`len(s1)+k`，开始遍历字符串`s2`:
    - 取滑动窗口内的词频统计`c2`，比较`c1`和`c2`
    - 如果`c1`小，则找到了元素下标，并返回结果
    - 如果`c1`大，则继续遍历。
3. 如果没有找到，则返回-1。    

## 解题代码

```python
from collections import Counter


def solve_method(s1, s2, k):
    c1 = Counter(s1)
    for i in range(len(s2) - len(s1) - k):
        c2 = Counter(s2[i:i + len(s1) + k])
        if c1 < c2:
            return i

    return - 1


if __name__ == '__main__':
    assert solve_method("ab", "aabcd", 1) == 0
    assert solve_method("abc", "dfs", 10) == -1
```
