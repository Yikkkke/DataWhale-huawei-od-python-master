# 043 自动曝光

## 题目描述

一个图像有`n`个像素点，存储在一个长度为`n`的数组`img`里，每个像素点的取值范围[0,255]的正整数。请你给图像每个像素点值加上一个整数`k`（可以是负数），得到新图`new_img`，使得新图`new_img`的所有像素平均值最接近中位值128。请输出这个整数`k`。

## 输入描述

输入`n`个整数，中间用空格分开，例如：`0 0 0 0`，4个数值，中间用空格分开。

## 输出描述

输出一个整数`k`。  

**备注：**
- 1 <= n <= 100
- 如有多个整数`k`都满足，输出小的那个`k`。
- 新图的像素值会自动截取到[0,255]范围。当新像素值<0，其值会更改为0；当新像素值>255，其值会更改为255。

例如：new_img="-1 -2 256 -1"，会自动更改为`0 0 255 0`。

## 示例描述

### 示例一

**输入：**
```text
0 0 0 0
```

**输出：**
```text
128
```

**说明：**  

四个像素值都为0。

### 示例二

**输入：**
```text
129 130 129 130
```

**输出：**
```text
-2
```

**说明：**  
-1的均值128.5，-2的均值为127.5，输出较小的数-2。

## 解题思路

1. 计算当前图像的像素均值与128的差值`diff`。
2. 比较差值：
   - 如果差值大于0，则`k`是负数，将`k`持续减1，计算新图像的像素均值，使其大于127。
   - 如果差值小于0，则`k`是正数，将`k`持续加1，计算新图像的像素均值，使其小于128。
3. 返回`k`值。

## 解题代码

```python
def solve_method(img):
    avg = sum(img) // len(img)
    diff = avg - 128
    new_img = img.copy()

    k = 0
    if diff > 0:
        # 如果差值大于0，则k是负数
        while avg > 127:
            k -= 1
            avg = get_new_image_avg(new_img, k)
    if diff < 0:
        # 如果差值小于0，则k是正数
        while avg < 128:
            k += 1
            avg = get_new_image_avg(new_img, k)
    return k


def get_new_image_avg(new_img, k):
    new_img = [min(max(0, x + k), 255) for x in new_img]
    return sum(new_img) // len(new_img)


if __name__ == '__main__':
    assert solve_method([0, 0, 0, 0]) == 128
    assert solve_method([129, 130, 129, 130]) == -2
```